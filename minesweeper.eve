# Minesweeper

## Program

Set some constants and generate the grid cells to hold the board state.
```
search
  width = 5
  height = 5
  area = width * height
  mines = 3
  cell-size = 30

  i = range[from: 0, to: width - 1]
  j = range[from: 0, to: height - 1]
commit
  [#board width height area cell-size mines unplaced-mines: mines]
  [#cell row: i column: j]
```
Place the mines. This is structured as a loop and has an iterative random
number generator inlined. Random number generation in the standard library
would significantly simplify this clause. To avoid excessive thrashing the
other clauses in this program are guarded from running until this is complete.
```
search
  board = [#board width height area unplaced-mines unplaced-mines > 0]
  rnd = random[seed: unplaced-mines]
  cell-number = floor[value: rnd * area]
  column = mod[value: cell-number by: width]
  row = floor[value: cell-number / height]
  cell = [#cell row column]
  dec-unplaced = if cell = [#has-mine] then 0
                 else 1
commit
  cell += #has-mine
  board.unplaced-mines := unplaced-mines - dec-unplaced
  board.rnd := rnd
```
Make each cell keep track of its neighbors.
```
search
  board = [#board unplaced-mines: 0 not(#initialised)]
  this-cell = [#cell row: this-row column: this-column]
  i = range[from: -1, to: 1]
  j = range[from: -1, to: 1]
  this-neighbor = [#cell row: this-row + i column: this-column + j]
  not(this-cell = this-neighbor)
commit
  board += #initialised
  this-cell.neighbor += this-neighbor
```
Count how many neighbors with mines each cell has. Note that this doesn't tag
0.
```
search
  [#board #initialised]
  this-cell = [#cell not(#has-mine) neighbor: mine-neighbor]
  mine-neighbor = [#has-mine]
bind
  this-cell.neighbor-mines := count[given: mine-neighbor per: this-cell]
```
Make the revealed cells.
```
search (@browser, @session)
  [#board #initialised width cell-size]
  cell = [#cell #revealed]
  cell-div = [#div #cell-div cell]
  revealed-contents =
    if cell = [#has-mine] then "x"
    else if cell.neighbor-mines then "{{cell.neighbor-mines}}"
    else "."
commit @browser
  cell-div.children :=
    [#div cell text: revealed-contents style:
     [display: "inline-block"
      width: "{{cell-size}}px"
      height: "{{cell-size}}px"
      border: "1px solid black"
      background: "white"
      font-size: "2em"
      line-height: "{{cell-size}}px"
      text-align: "center"]]
```
Make the unrevealed cells.
```
search (@browser, @session)
  board = [#board #initialised width cell-size]
  cell = [#cell not(#revealed)]
  cell-div = [#div #cell-div cell]
commit @browser
  cell-div.children :=
    [#button #cell-button cell style:
     [display: "inline-block"
      width: "{{cell-size}}px"
      height: "{{cell-size}}px"
      line-height: "{{cell-size}}px"]]
```
Draw the board. This could definitely benefit from a separate style sheet.
```
search
  board = [#board #initialised unplaced-mines: 0 width cell-size]
  cell = [#cell row column]
  container-width = cell-size * width
  container-height = cell-size * width
  big-font-size = container-width / 6
  font-size = cell-size * 0.5
  game-over-text =
    if board = [#won] then "YOU WIN"
    else if board = [#lost] then "GAME OVER"
    else ""
bind @browser
  [#div style:
    [position: "relative"
     font-size: "{{big-font-size}}px"
     text-align: "center"]
    children:
      [#div sort: 0
        text: game-over-text style:
        [position: "absolute"
         left: "50%"
         top: "50%"
         z-index: 1
         transform: "translateX(-50%) translateY(-50%)"
         text-shadow: "white -1px 1px, white -2px 2px, white -3px 3px"]]
    children:
      [#div sort: 1
        style:
        [color: "black"
         font-size: "{{font-size}}px"]
       children:
         [#div sort: column
          children: [#div #cell-div cell sort: row 
                     style: [display: "inline"]]]]]
```
Clicking reveals a cell.
```
search (@browser, @session)
  [#click element: [#cell-button cell]]
commit
  cell += #revealed
```
A revealed cell with no neighbor mines reveals all neighbor cells.
```
search
  [#board #initialised]
  this-cell = [#cell #revealed row: this-row column: this-column
               not(neighbor-mines) not(#has-mine)
               neighbor: to-reveal]
bind
  to-reveal += #revealed
```
If a mine is revealed that's game over.
```
search
  board = [#board #initialised]
  [#cell #has-mine #revealed]
bind
  board += #game-over
  board += #lost
```
If only mines are unrevealed that's a win.
```
search
  board = [#board area #initialised]
  not([#cell #has-mine #revealed])
  cells-completed = count[given: [#cell #revealed]] +
                    count[given: [#cell #has-mine]]
  cells-completed = area
bind
  board += #game-over
  board += #won
```
Clicking restarts the game. This doesn't work currently and instead just
removes everything. I think this might be a bug in Eve.
```
search (@browser)
  board = [#board mines #game-over]
  [#click]
  cell = [#cell]
commit
  board.unplaced-mines := mines
  cell -= #has-mine
  cell -= #revealed
```

## Todo

 * Marking mines/question marks - just as soon as there's a way to detect
   right-click in Eve again
 * Use random function from the standard library
 * Fix restart
 * Use external style sheet
 * Configuration dialog
 * Restart button
 * Smiley / frowny / O-face
 * Other touches to get that mid nineties look n' feel
